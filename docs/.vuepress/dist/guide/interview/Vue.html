<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Vue | 前端面试知识总结</title>
    <meta name="description" content="自家使用,暂不外传">
    <meta name="generator" content="VuePress 1.3.1">
    <link rel="icon" href="/favicon.ico">
    
    <link rel="preload" href="/assets/css/0.styles.6a4803ab.css" as="style"><link rel="preload" href="/assets/js/app.81dd3622.js" as="script"><link rel="preload" href="/assets/js/2.d1b1e148.js" as="script"><link rel="preload" href="/assets/js/15.c6286125.js" as="script"><link rel="preload" href="/assets/js/4.a3faee54.js" as="script"><link rel="prefetch" href="/assets/js/10.42124fbe.js"><link rel="prefetch" href="/assets/js/11.bdef2e64.js"><link rel="prefetch" href="/assets/js/12.9c5e83ed.js"><link rel="prefetch" href="/assets/js/13.3db43aaf.js"><link rel="prefetch" href="/assets/js/14.8f2ec86d.js"><link rel="prefetch" href="/assets/js/16.5da2b31d.js"><link rel="prefetch" href="/assets/js/17.c9deef07.js"><link rel="prefetch" href="/assets/js/18.13ed30af.js"><link rel="prefetch" href="/assets/js/19.f1a01180.js"><link rel="prefetch" href="/assets/js/20.30f7288c.js"><link rel="prefetch" href="/assets/js/21.477730e4.js"><link rel="prefetch" href="/assets/js/22.ab119ff1.js"><link rel="prefetch" href="/assets/js/23.9bbc22fc.js"><link rel="prefetch" href="/assets/js/24.cb1899b8.js"><link rel="prefetch" href="/assets/js/25.64669f1d.js"><link rel="prefetch" href="/assets/js/26.f3040183.js"><link rel="prefetch" href="/assets/js/27.2938dd4c.js"><link rel="prefetch" href="/assets/js/28.cd87026d.js"><link rel="prefetch" href="/assets/js/29.b92287f4.js"><link rel="prefetch" href="/assets/js/3.103e70cb.js"><link rel="prefetch" href="/assets/js/30.af43d48f.js"><link rel="prefetch" href="/assets/js/31.8c7148f5.js"><link rel="prefetch" href="/assets/js/32.d42beb3f.js"><link rel="prefetch" href="/assets/js/33.223bba8e.js"><link rel="prefetch" href="/assets/js/34.04b12083.js"><link rel="prefetch" href="/assets/js/35.19c65fa0.js"><link rel="prefetch" href="/assets/js/36.a1a664b9.js"><link rel="prefetch" href="/assets/js/37.d2e7a2dd.js"><link rel="prefetch" href="/assets/js/38.4f737159.js"><link rel="prefetch" href="/assets/js/39.fcdeadea.js"><link rel="prefetch" href="/assets/js/40.40a9daf9.js"><link rel="prefetch" href="/assets/js/5.2f32d917.js"><link rel="prefetch" href="/assets/js/6.d92ecc16.js"><link rel="prefetch" href="/assets/js/7.a09f8ef2.js"><link rel="prefetch" href="/assets/js/8.5b00daa2.js"><link rel="prefetch" href="/assets/js/9.9d06f44a.js">
    <link rel="stylesheet" href="/assets/css/0.styles.6a4803ab.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">前端面试知识总结</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link">
  首页
</a></div><div class="nav-item"><a href="/guide/" class="nav-link router-link-active">
  指南
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="项目" class="dropdown-title"><span class="title">项目</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/project/shop/" class="nav-link">
  大型电商
</a></li><li class="dropdown-item"><!----> <a href="/project/music/" class="nav-link">
  vue实现音乐app
</a></li></ul></div></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link">
  首页
</a></div><div class="nav-item"><a href="/guide/" class="nav-link router-link-active">
  指南
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="项目" class="dropdown-title"><span class="title">项目</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/project/shop/" class="nav-link">
  大型电商
</a></li><li class="dropdown-item"><!----> <a href="/project/music/" class="nav-link">
  vue实现音乐app
</a></li></ul></div></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>目录</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/guide/" class="sidebar-link">项目介绍</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>css基础到进阶</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/guide/css/test.html" class="sidebar-link">移动端问题</a></li><li><a href="/guide/css/layout.html" class="sidebar-link">前端常见布局</a></li><li><a href="/guide/css/alwaysCode.html" class="sidebar-link">常用css片段</a></li><li><a href="/guide/css/iconfont.html" class="sidebar-link">全局stylus配置及使用iconfont</a></li><li><a href="/guide/css/css-skill.html" class="sidebar-link">灵活使用css技巧</a></li><li><a href="/guide/css/code.html" class="sidebar-link">code pratice</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>js基础</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/guide/js/base.html" class="sidebar-link">基础</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>js进阶</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/guide/js/higher.html" class="sidebar-link">js??</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>MVVM分析</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/guide/vue/vue.html" class="sidebar-link">vue 基础部分</a></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Webpack实战分析</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Node.js基础到进阶</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>面试题总结</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/guide/interview/test.html" class="sidebar-link">JS基础</a></li><li><a href="/guide/interview/web-api.html" class="sidebar-link">JS-Web-API</a></li><li><a href="/guide/interview/git.html" class="sidebar-link">Git总结</a></li><li><a href="/guide/interview/broswer.html" class="sidebar-link">浏览器</a></li><li><a href="/guide/interview/miniprogrammer.html" class="sidebar-link">小程序</a></li><li><a href="/guide/interview/Vue.html" class="active sidebar-link">Vue</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/guide/interview/Vue.html#vue基础知识点" class="sidebar-link">Vue基础知识点</a></li><li class="sidebar-sub-header"><a href="/guide/interview/Vue.html#vue原理部分-核心重点" class="sidebar-link">Vue原理部分(核心重点)</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/guide/interview/Vue.html#mvvm" class="sidebar-link">MVVM</a></li><li class="sidebar-sub-header"><a href="/guide/interview/Vue.html#vue响应式原理" class="sidebar-link">Vue响应式原理</a></li><li class="sidebar-sub-header"><a href="/guide/interview/Vue.html#虚拟dom" class="sidebar-link">虚拟DOM</a></li></ul></li><li class="sidebar-sub-header"><a href="/guide/interview/Vue.html#常考面试题" class="sidebar-link">常考面试题</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/guide/interview/Vue.html#聊一下mvvm" class="sidebar-link">聊一下MVVM</a></li><li class="sidebar-sub-header"><a href="/guide/interview/Vue.html#简单说一下vue2-x响应式数据原理" class="sidebar-link">简单说一下Vue2.x响应式数据原理</a></li><li class="sidebar-sub-header"><a href="/guide/interview/Vue.html#nexttick知道吗，实现原理是什么？" class="sidebar-link">nextTick知道吗，实现原理是什么？</a></li><li class="sidebar-sub-header"><a href="/guide/interview/Vue.html#vue中的组件data为什么必须是函数？？" class="sidebar-link">Vue中的组件data为什么必须是函数？？</a></li><li class="sidebar-sub-header"><a href="/guide/interview/Vue.html#谈一下vue生命周期" class="sidebar-link">谈一下VUE生命周期</a></li><li class="sidebar-sub-header"><a href="/guide/interview/Vue.html#谈一下-nexttick" class="sidebar-link">谈一下$nextTick</a></li><li class="sidebar-sub-header"><a href="/guide/interview/Vue.html#谈一下computed和watch" class="sidebar-link">谈一下computed和watch</a></li><li class="sidebar-sub-header"><a href="/guide/interview/Vue.html#说一下v-if和v-show的区别" class="sidebar-link">说一下v-if和v-show的区别</a></li><li class="sidebar-sub-header"><a href="/guide/interview/Vue.html#说一下v-model的原理" class="sidebar-link">说一下v-model的原理</a></li><li class="sidebar-sub-header"><a href="/guide/interview/Vue.html#vue事件绑定原理说一下" class="sidebar-link">Vue事件绑定原理说一下</a></li><li class="sidebar-sub-header"><a href="/guide/interview/Vue.html#vue模板编译原理" class="sidebar-link">VUE模板编译原理</a></li><li class="sidebar-sub-header"><a href="/guide/interview/Vue.html#vue-diff算法" class="sidebar-link">VUE diff算法</a></li><li class="sidebar-sub-header"><a href="/guide/interview/Vue.html#再说一下虚拟dom" class="sidebar-link">再说一下虚拟Dom</a></li><li class="sidebar-sub-header"><a href="/guide/interview/Vue.html#vue中组件生命周期调用顺序说一下" class="sidebar-link">Vue中组件生命周期调用顺序说一下</a></li><li class="sidebar-sub-header"><a href="/guide/interview/Vue.html#vue2-x组件通信有哪些方式？" class="sidebar-link">Vue2.x组件通信有哪些方式？</a></li><li class="sidebar-sub-header"><a href="/guide/interview/Vue.html#vue性能优化" class="sidebar-link">VUE性能优化</a></li></ul></li></ul></li><li><a href="/guide/interview/project.html" class="sidebar-link">项目总结</a></li><li><a href="/guide/interview/always.html" class="sidebar-link">面试通用回答</a></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="vue"><a href="#vue" class="header-anchor">#</a> Vue</h1> <h2 id="vue基础知识点"><a href="#vue基础知识点" class="header-anchor">#</a> Vue基础知识点</h2> <p><a href="http://note.youdao.com/noteshare?id=b5e31d39849dcba01d11542ba146225b" target="_blank" rel="noopener noreferrer">原文链接<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <p>这个是两年前初学<code>Vue</code>总结的,所以文笔略显粗糙,后续将重新总结</p> <h2 id="vue原理部分-核心重点"><a href="#vue原理部分-核心重点" class="header-anchor">#</a> Vue原理部分(核心重点)</h2> <h3 id="mvvm"><a href="#mvvm" class="header-anchor">#</a> MVVM</h3> <p><code>MVVM</code>传统的<code>MVC</code>模型主要区分于<code>Controller</code>层,简称数据驱动模型,就是<code>vm</code>层的作用就是:数据绑定在<code>vm</code>层，并自动渲染页面,页面发生变化时会通知<code>vm</code>层更新数据。</p> <h3 id="vue响应式原理"><a href="#vue响应式原理" class="header-anchor">#</a> Vue响应式原理</h3> <p><strong><code>data</code>是如何已发生改变就立即渲染页面的?</strong></p> <p>通过核心的API:<code>Object.defineProperty</code>来监听数据,达到将变量当做函数一样监听的效果。</p> <p>简单的监听</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> data <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token keyword">const</span> name <span class="token operator">=</span> <span class="token string">'zhangsan'</span>
<span class="token comment">// 监听name,将name当做data的属性</span>
Object<span class="token punctuation">.</span><span class="token function">defineProperty</span><span class="token punctuation">(</span>data<span class="token punctuation">,</span><span class="token string">'name'</span><span class="token punctuation">,</span><span class="token punctuation">{</span>
  <span class="token function-variable function">get</span><span class="token operator">:</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">return</span> name
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token function-variable function">set</span><span class="token operator">:</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">val</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    name <span class="token operator">=</span> val
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>

<span class="token operator">...</span><span class="token punctuation">.</span> 
<span class="token comment">// use</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>data<span class="token punctuation">.</span>name<span class="token punctuation">)</span> <span class="token comment">//zhangsan</span>
data<span class="token punctuation">.</span>name <span class="token operator">=</span>  <span class="token string">'lisi'</span> 
</code></pre></div><p>深度改造: 支持结构复杂的对象或者数组监听</p> <blockquote><p>判断是否是引用类型,然后遍历监听,监听过程中递归<code>value</code>,因为可能是深层次结构</p></blockquote> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">observer</span><span class="token punctuation">(</span><span class="token parameter">target</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> target <span class="token operator">!==</span> <span class="token string">'object'</span> <span class="token operator">||</span> target <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">return</span> target
  <span class="token punctuation">}</span>
  <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> key <span class="token keyword">in</span> target<span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token function">defineRective</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span>key<span class="token punctuation">,</span>target<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">defineRective</span><span class="token punctuation">(</span><span class="token parameter">data<span class="token punctuation">,</span>key<span class="token punctuation">,</span>value</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  <span class="token comment">// value可能是复杂对象 递归监听</span>
  <span class="token function">observer</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span>
  Object<span class="token punctuation">.</span><span class="token function">defineProperty</span><span class="token punctuation">(</span>data<span class="token punctuation">,</span>key<span class="token punctuation">,</span><span class="token punctuation">{</span>
    <span class="token function-variable function">get</span><span class="token operator">:</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
      <span class="token keyword">return</span> value
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token function-variable function">set</span><span class="token operator">:</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">newVal</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
      <span class="token comment">// 深度监听</span>
      <span class="token function">observer</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span>
      <span class="token keyword">if</span><span class="token punctuation">(</span>value <span class="token operator">===</span> newVal<span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">return</span>
      <span class="token punctuation">}</span>
        value <span class="token operator">=</span> newVal
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><p><strong>监听数组变化</strong></p> <p>这样虽然能够监听深层对象或值,但是还是无法监听数组,这里需要改造<code>target</code>的原型</p> <ul><li>重新定义数组原型方法,不能污染全局,使用<code>Object.create</code></li> <li>扩展方法,增加视图更新方法和原生数组方法</li> <li>目标原型指向定义的变量</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> ArrayObject <span class="token operator">=</span> <span class="token class-name">Array</span><span class="token punctuation">.</span>prototype
<span class="token comment">// 将ArraayObject原型指向他,然后扩展方法 即继承数组方法,不影响定义新方法</span>
<span class="token keyword">const</span> arrayob <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span>ArrayObject<span class="token punctuation">)</span>
<span class="token punctuation">[</span><span class="token string">'push'</span><span class="token punctuation">,</span><span class="token string">'shift'</span><span class="token punctuation">,</span><span class="token string">'unshift'</span><span class="token punctuation">,</span><span class="token string">'pop'</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">methodName</span><span class="token punctuation">)</span><span class="token operator">=&gt;</span><span class="token punctuation">{</span>
   <span class="token comment">// 扩展的方法</span>
  arrayob<span class="token punctuation">[</span>methodName<span class="token punctuation">]</span><span class="token operator">=</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
   console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'视图更新'</span><span class="token punctuation">)</span>
   <span class="token comment">// 真正意义上的调用原生方法</span>
   ArrayObject<span class="token punctuation">[</span>methodName<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span><span class="token operator">...</span>arguments<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>

<span class="token operator">...</span><span class="token punctuation">.</span>
<span class="token comment">// 使用的时候将原型指向arrayob即可</span>

<span class="token keyword">if</span><span class="token punctuation">(</span>target <span class="token keyword">instanceof</span> <span class="token class-name">Array</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  target<span class="token punctuation">.</span>__proto__ <span class="token operator">=</span> arrayob
<span class="token punctuation">}</span>
<span class="token keyword">const</span> data <span class="token operator">=</span><span class="token punctuation">{</span>
  nums<span class="token operator">:</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">]</span>
<span class="token punctuation">}</span>

data<span class="token punctuation">.</span>nums<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span> <span class="token comment">// 视图更新 此处调用arrayob的方法</span>
</code></pre></div><div class="custom-block tip"><p class="custom-block-title">defineProperty缺点</p> <ul><li>深度监听,一次性递归到底，计算量大</li> <li>无法监听新增删除,必须使用<code>Vue.set</code>或者<code>Vue.delete</code></li> <li>无法实现数组监听,必须要改造</li></ul></div> <h3 id="虚拟dom"><a href="#虚拟dom" class="header-anchor">#</a> 虚拟DOM</h3> <p>传统dom操作: 耗时耗费性能。</p> <p>虚拟<code>dom</code>操作<strong>利用<code>js</code>的执行速度很快</strong>,先利用<code>js</code>模拟<code>dom</code>结构,然后计算出最小的变更,操作<code>dom</code></p> <p>模拟<code>DOM</code>结构</p> <p><img src="https://raw.githubusercontent.com/imageList/imglist/master/20200709125703.png" alt="20200709125703.png"></p> <p>更多内容待补充</p> <h2 id="常考面试题"><a href="#常考面试题" class="header-anchor">#</a> 常考面试题</h2> <h3 id="聊一下mvvm"><a href="#聊一下mvvm" class="header-anchor">#</a> 聊一下MVVM</h3> <p>MVVM不同于MVC的地方在于将<code>Controller</code>变成了<code>VM</code>层,VM层:ViewModel层,数据驱动视图层。数据绑定到<code>VM</code>层,然后会自动渲染页面,当页面发生变化时会通知<code>VM</code>层更新数据。</p> <h3 id="简单说一下vue2-x响应式数据原理"><a href="#简单说一下vue2-x响应式数据原理" class="header-anchor">#</a> 简单说一下Vue2.x响应式数据原理</h3> <p>VUE响应式原理核心是使用到了<code>Object.defineProperty</code>这个<code>API</code>,VUE重新定义<code>data</code>里面的属性,当页面使用属性时,属性发生变化,就可以监听变化通知进行更新操作。</p> <h3 id="nexttick知道吗，实现原理是什么？"><a href="#nexttick知道吗，实现原理是什么？" class="header-anchor">#</a> nextTick知道吗，实现原理是什么？</h3> <p><code>dom</code>更新结束后执行的延时回调函数。主要使用了宏任务和微任务。</p> <p>根据执行环境分别尝试采用</p> <ul><li><strong>Promise</strong></li> <li><strong>MutationObserver</strong></li> <li><strong>setImmediate</strong></li> <li><strong>如果以上都不行则采用setTimeout</strong></li></ul> <h3 id="vue中的组件data为什么必须是函数？？"><a href="#vue中的组件data为什么必须是函数？？" class="header-anchor">#</a> Vue中的组件data为什么必须是函数？？</h3> <p>因为组件是可以复用的，js里对象是引用关系，<strong>如果组件data是一个对象，那么子组件中的data属性值会<code>互相污染</code>，产生不必要的麻烦</strong>。所以一个组件中的data必须是一个函数，因此<strong>每个实例可以维护一份被返回对象独立的拷贝</strong>。也因为new Vue的实例是不会被复用，所以不存在以上问题。</p> <h3 id="谈一下vue生命周期"><a href="#谈一下vue生命周期" class="header-anchor">#</a> 谈一下VUE生命周期</h3> <ul><li><p>beforeCreate: new Vue()之后执行的第一个钩子,<strong>这个期间<code>methods</code>,<code>computed</code>,<code>data</code>数据都无法获取</strong></p></li> <li><p>created: <strong>实例创建完成</strong>后,完成数据侦测,<strong>虽然可以获取数据,但是无法完成<code>dom</code>交互</strong></p></li> <li><p>beforeMount: 发生在挂载之前,<strong>当前阶段虚拟<code>dom</code>已经创建完成</strong>,如果更改数据<strong>不会触发<code>updated</code></strong></p></li> <li><p>mounted: 挂载结束,<strong>已完成双向绑定,可以访问到DOM节点,可以使用<code>$refs</code>操作<code>dom</code></strong></p></li> <li><p>beforeUpdate: <strong>响应式数据更新之前,虚拟<code>dom</code>重新渲染之前</strong>。</p></li> <li><p>updated: 发生在更新完成之后，<strong>当前阶段组件Dom已完成更新</strong>。要注意的是避免在此期间更改数据，因为这可能会导致无限循环的更新。</p></li> <li><p>beforeDestory: 发生在实例销毁之前，<strong>在当前阶段实例完全可以被使用，我们可以在这时进行善后收尾工作</strong>，比如清除计时器</p></li> <li><p>destoryed: 发生在实例销毁之后，<strong>这个时候只剩下了dom空壳</strong>。组件已被拆解，数据绑定被卸除，监听被移出，子实例也统统被销毁</p></li></ul> <h3 id="谈一下-nexttick"><a href="#谈一下-nexttick" class="header-anchor">#</a> 谈一下$nextTick</h3> <p>nextTick: 数据更新,dom渲染后执行的回调函数</p> <p>原理: 有待学习</p> <p>使用场景:</p> <ol><li>created中操作dom</li> <li>对更新的dom进行一系列操作时</li> <li>使用插件时,希望dom重新应用插件(比如数据变化后，使用的better-scroll插件需要在nextTick中调用better-scroll的刷新api)</li></ol> <h3 id="谈一下computed和watch"><a href="#谈一下computed和watch" class="header-anchor">#</a> 谈一下computed和watch</h3> <p><code>Computed</code>本质是一个具备缓存的watcher，依赖的属性发生变化就会更新视图。 适用于计算比较消耗性能的计算场景。主要使用在<code>dom</code>属性更新。</p> <p><code>Watch</code>没有缓存性，更多的是观察的作用，可以监听某些数据执行回调。当我们需要深度监听对象中的属性时，可以打开<code>deep：true</code>选项。</p> <h3 id="说一下v-if和v-show的区别"><a href="#说一下v-if和v-show的区别" class="header-anchor">#</a> 说一下v-if和v-show的区别</h3> <p><code>v-if</code>: 隐藏的话不会渲染<code>dom</code>。
<code>v-show</code>: 本质控制<code>display:none</code>,节省性能。</p> <h3 id="说一下v-model的原理"><a href="#说一下v-model的原理" class="header-anchor">#</a> 说一下v-model的原理</h3> <p><code>v-model</code>本质是一个语法糖,可以看做是<code>input</code>和<code>value</code>的语法堂。可以更改<code>prop</code>和<code>event</code>来实现自定义<code>model</code>。</p> <h3 id="vue事件绑定原理说一下"><a href="#vue事件绑定原理说一下" class="header-anchor">#</a> Vue事件绑定原理说一下</h3> <p>原生是利用<code>addEventListener</code>实现的,组件事件通过<code>$on</code>绑定。</p> <h3 id="vue模板编译原理"><a href="#vue模板编译原理" class="header-anchor">#</a> VUE模板编译原理</h3> <ul><li>生成<code>AST</code>树</li> <li>优化</li> <li>生成可执行代码</li></ul> <p>首先解析模板,生成<code>AST语法树</code>(对象形式描述模板)。使用大量正则表达式对末班进行解析。</p> <p>Vue数据是响应式的,但其实模板并不是所有的都是响应式的,Vue深层遍历<code>AST</code>树,按照条件标记节点,然后就可以跳过比对，起到优化作用。</p> <p>最后一步,将优化过的<code>AST</code>树转为可执行代码。</p> <h3 id="vue-diff算法"><a href="#vue-diff算法" class="header-anchor">#</a> VUE diff算法</h3> <h3 id="再说一下虚拟dom"><a href="#再说一下虚拟dom" class="header-anchor">#</a> 再说一下虚拟Dom</h3> <p>由于在浏览器中操作DOM是很昂贵的。频繁的操作DOM，会产生一定的性能问题。这就是虚拟Dom的<code>产生原因</code>。</p> <p><code>Virtual DOM本质就是用一个原生的JS对象去描述一个DOM节点</code>。是对真实DOM的一层抽象。</p> <h3 id="vue中组件生命周期调用顺序说一下"><a href="#vue中组件生命周期调用顺序说一下" class="header-anchor">#</a> Vue中组件生命周期调用顺序说一下</h3> <p>组件的调用顺序都是先父后子,渲染完成的顺序是先子后父。</p> <p>组件的销毁操作是先父后子，销毁完成的顺序是先子后父。</p> <p>加载渲染过程: 先子后父</p> <p><code>父beforeCreate-&gt;父created-&gt;父beforeMount-&gt;子beforeCreate-&gt;子created-&gt;子beforeMount- &gt;子mounted-&gt;父mounted</code></p> <p>子组件更新过程</p> <p><code>父beforeUpdate-&gt;子beforeUpdate-&gt;子updated-&gt;父updated</code></p> <p>父组件更新</p> <p><code>父beforeUodate -&gt; updated</code></p> <p>销毁过程</p> <p><code>父beforeDestroy-&gt;子beforeDestroy-&gt;子destroyed-&gt;父destroyed</code></p> <h3 id="vue2-x组件通信有哪些方式？"><a href="#vue2-x组件通信有哪些方式？" class="header-anchor">#</a> Vue2.x组件通信有哪些方式？</h3> <ul><li>父子组件通信</li></ul> <p>父-&gt;子<code>props</code>，子-&gt;父 <code>$on</code>、<code>$emit</code></p> <p>获取父子组件实例 <code>$parent</code>、<code>$children</code></p> <p><code>Ref</code> 获取实例的方式调用组件的属性或者方法</p> <ul><li>兄弟组件通信</li></ul> <p><code>Event Bus</code> 实现跨组件通信 <code>Vue.prototype.$bus = new Vue</code></p> <p><code>Vuex</code></p> <ul><li>跨组件</li></ul> <p><code>Vuex</code></p> <h3 id="vue性能优化"><a href="#vue性能优化" class="header-anchor">#</a> VUE性能优化</h3> <ul><li>尽量减少data中的数据，data中的数据都会增加getter和setter，会收集对应的watcher</li> <li>v-if和v-for不能连用如果需要使用v-for给每项元素绑定事件时使用事件代理</li> <li>SPA 页面采用keep-alive缓存组件</li> <li>在更多的情况下，使用v-if替代v-show</li> <li>key保证唯一</li> <li>使用路由懒加载、异步组件</li> <li>防抖、节流</li> <li>第三方模块按需导入</li> <li>长列表滚动到可视区域动态加载</li> <li>图片懒加载</li></ul></div> <footer class="page-edit"><!----> <div class="last-updated"><span class="prefix">Last update:</span> <span class="time">8/25/2020, 2:31:00 PM</span></div></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/guide/interview/miniprogrammer.html" class="prev">
        小程序
      </a></span> <span class="next"><a href="/guide/interview/project.html">
        项目总结
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"><!----><!----></div></div>
    <script src="/assets/js/app.81dd3622.js" defer></script><script src="/assets/js/2.d1b1e148.js" defer></script><script src="/assets/js/15.c6286125.js" defer></script><script src="/assets/js/4.a3faee54.js" defer></script>
  </body>
</html>
