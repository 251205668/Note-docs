## 回溯算法

[完整地址](https://labuladong.gitee.io/algo/%E7%AE%97%E6%B3%95%E6%80%9D%E7%BB%B4%E7%B3%BB%E5%88%97/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E8%AF%A6%E8%A7%A3%E4%BF%AE%E8%AE%A2%E7%89%88.html)

[TS版本](https://github.com/i-want-offer/FE-Essay/blob/master/docs/%E7%AE%97%E6%B3%95/%E5%88%B7%E9%A2%98%E5%A5%97%E8%B7%AF/%E7%AC%AC%E9%9B%B6%E7%AB%A0%E3%80%81%E5%BF%85%E8%AF%BB%E7%B3%BB%E5%88%97/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E8%A7%A3%E9%A2%98%E5%A5%97%E8%B7%AF%E6%A1%86%E6%9E%B6.md)

### 回溯算法模板

**注意：递归操作传入的路径数组一定要做一层浅拷贝，不然结果不一致**

```js
result = []
function backtrack(路径，选择列表) {
	if 满足结束条件：
		result.push(路径)
		return 
	for 选择 in 选择列表：
		做选择
		backtrack(路径，选择列表)
		撤销选择
}

1、路径：也就是已经做出的选择。

2、选择列表：也就是你当前可以做的选择。

3、结束条件：也就是到达决策树底层，无法再做选择的条件。
```
```
简单讲就是定义一个回溯方法
第一步确定结束条件，也就是到达决策树底部
第二部就是去遍历选择列表，三部曲：做选择(track.push(num))+递归回溯+撤销选择(track.pop())
```

### 快速理解回溯算法

计算[1,2,3]的全排列二维数组结果

解题步骤:

1. 画出决策树

![](https://image.yangxiansheng.top/img/20201222181107.png?imglist)

2. 总结出以下规律:
  - 每次做出决策之后，路径数组都会添加已经选择的节点，选择列表删除已选择节点
  - 便利过程中，路径中绝对不会包含下一选择节点，有则跳过此轮循环
  - 当路径元素和选择列表元素相同，结束循环，返回结果

![](https://image.yangxiansheng.top/img/20201222180844.png?imglist)
```js
for 选择 in 选择列表：
		# 做选择
		将该选择从选择列表移除
		路径.push(选择)
		backtrack(路径，选择列表)
		# 撤销操作
		路径.pop(选择)
		将该选择再加入选择列表
```

所以以上解法

```js
var permute = function(nums) {
  let res = []
  function backTrack(track){
      if(track.length === nums.length){
          res.push(track)
          return 
      }
      for(let num of nums){
          // 下一选择节点不能再路径中
          if(track.includes(num)){
              continue
          }
          // 做选择
          track.push(num)
          // 递归
          backTrack(track.slice())
          // 撤销选择
          track.pop()
      }
  }
  backTrack([])
  return res
};
```
### 解决全排列，N皇后问题

1. 全排列前文已经讲解

2. [N皇后(hard)](https://leetcode-cn.com/problems/n-queens/)

题目大概描述:
![](https://image.yangxiansheng.top/img/20201222192806.png?imglist)

给定一个NxN的棋盘，如何将 n 个皇后放置在 n×n 的棋盘上，并且使皇后彼此之间不能相互攻击(皇后的左上方，右上方，本列都不允许出现另一个皇后)


**解题思路:**

这道题也是经典的回溯算法(有去的路也有死路)，决策树上的每一层代表棋盘的行，这一行的所有列代表选择列表

```js
还是老样子首先第一步还是先写出选择列表，路径和结束条件

1. 选择列表: 每一层row的任意行，都可以放置皇后
2. 路径: 这里的路径和全排列的路径不同，这里比较抽象，将它想象成row在遍历着，皇后也在放置着，最后的棋盘长啥样，路径就是啥
3. 结束条件: row = 棋盘的N
```

套公式即可

```js
var solveNQueens = function(n) {
  const res = []
  // 路径参数为棋盘和row
  function backStack(board,row){
    // 结束递归
    if(row === n){
      res.push(board)
      return
    }
    // 遍历选择列表
    for(var col = 0;col < n;i++){
      // 1. 排除不合法的棋子
      if(!isValid(board,row,col)){
        continue
      }
      var letter = board[row].split("")
      // 做选择
      letter[col] = "Q"
      board[row] = letter.join("")
      // 递归
      backStack(board.slice(),row+1)
      //撤销
      letter[col] = "."
      board[row] = letter.join("")
    }

  }
  // 题意：左上方，右上方，本列不允许出现皇后
  function isVaild(board,row,col){
    // 本列
    for(let i =0;i < n;i++){
      if(board[i][col] === 'Q'){
        return false
      }
    }
    // 左上方
    for(let i = row-1,j = col-1;i>=0&&j>=0;i--,j--){
      if(board[i][j] === 'Q'){
        return false
      }
    }
    // 右上方
    for(let i = row-1,j=col+1;i>=0&&j<n;i--,j++){
      if(board[i][j] === 'Q'){
        return false
      }
    }
    return true
  }
/* 初始化棋盘 ，Array(4).fill(".".repeat(4))其实就是 声明长度为4的数组然后 填满4个点的字符串的元素
* ===>["....","....","....","...."]
*/
  backStack(Array(4).fill(".".repeat(4)),0)
  return res
};
```

**总结：**

凡是遇到有可寻的路径也有死路的问题都可以往回溯算法想，遇到题目先把三要素(选择列表，路径，结束条件)写出来，然后套用模板解题
