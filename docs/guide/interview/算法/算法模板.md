# 算法解题模板

## 回溯算法

[完整地址](https://labuladong.gitee.io/algo/%E7%AE%97%E6%B3%95%E6%80%9D%E7%BB%B4%E7%B3%BB%E5%88%97/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E8%AF%A6%E8%A7%A3%E4%BF%AE%E8%AE%A2%E7%89%88.html)

[TS版本](https://github.com/i-want-offer/FE-Essay/blob/master/docs/%E7%AE%97%E6%B3%95/%E5%88%B7%E9%A2%98%E5%A5%97%E8%B7%AF/%E7%AC%AC%E9%9B%B6%E7%AB%A0%E3%80%81%E5%BF%85%E8%AF%BB%E7%B3%BB%E5%88%97/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E8%A7%A3%E9%A2%98%E5%A5%97%E8%B7%AF%E6%A1%86%E6%9E%B6.md)

### 回溯算法模板

**注意：递归操作传入的路径数组一定要做一层浅拷贝，不然结果不一致**

```js
result = []
function backtrack(路径，选择列表) {
	if 满足结束条件：
		result.push(路径)
		return 
	for 选择 in 选择列表：
		做选择
		backtrack(路径，选择列表)
		撤销选择
}

1、路径：也就是已经做出的选择。

2、选择列表：也就是你当前可以做的选择。

3、结束条件：也就是到达决策树底层，无法再做选择的条件。
```
```
简单讲就是定义一个回溯方法
第一步确定结束条件，也就是到达决策树底部
第二部就是去遍历选择列表，三部曲：做选择(track.push(num))+递归回溯+撤销选择(track.pop())
```

### 快速理解回溯算法

计算[1,2,3]的全排列二维数组结果

解题步骤:

1. 画出决策树

![](https://image.yangxiansheng.top/img/20201222181107.png?imglist)

2. 总结出以下规律:
  - 每次做出决策之后，路径数组都会添加已经选择的节点，选择列表删除已选择节点
  - 便利过程中，路径中绝对不会包含下一选择节点，有则跳过此轮循环
  - 当路径元素和选择列表元素相同，结束循环，返回结果

![](https://image.yangxiansheng.top/img/20201222180844.png?imglist)
```js
for 选择 in 选择列表：
		# 做选择
		将该选择从选择列表移除
		路径.push(选择)
		backtrack(路径，选择列表)
		# 撤销操作
		路径.pop(选择)
		将该选择再加入选择列表
```

所以以上解法

```js
var permute = function(nums) {
  let res = []
  function backTrack(track){
      if(track.length === nums.length){
          res.push(track)
          return 
      }
      for(let num of nums){
          // 下一选择节点不能再路径中
          if(track.includes(num)){
              continue
          }
          // 做选择
          track.push(num)
          // 递归
          backTrack(track.slice())
          // 撤销选择
          track.pop()
      }
  }
  backTrack([])
  return res
};
```
### 解决全排列，N皇后问题

1. 全排列前文已经讲解

2. [N皇后(hard)](https://leetcode-cn.com/problems/n-queens/)

题目大概描述:
![](https://image.yangxiansheng.top/img/20201222192806.png?imglist)

给定一个NxN的棋盘，如何将 n 个皇后放置在 n×n 的棋盘上，并且使皇后彼此之间不能相互攻击(皇后的左上方，右上方，本列都不允许出现另一个皇后)


**解题思路:**

这道题也是经典的回溯算法(有去的路也有死路)，决策树上的每一层代表棋盘的行，这一行的所有列代表选择列表

```js
还是老样子首先第一步还是先写出选择列表，路径和结束条件

1. 选择列表: 每一层row的任意行，都可以放置皇后
2. 路径: 这里的路径和全排列的路径不同，这里比较抽象，将它想象成row在遍历着，皇后也在放置着，最后的棋盘长啥样，路径就是啥
3. 结束条件: row = 棋盘的N
```

套公式即可

```js
var solveNQueens = function(n) {
  const res = []
  // 路径参数为棋盘和row
  function backStack(board,row){
    // 结束递归
    if(row === n){
      res.push(board)
      return
    }
    // 遍历选择列表
    for(var col = 0;col < n;i++){
      // 1. 排除不合法的棋子
      if(!isValid(board,row,col)){
        continue
      }
      var letter = board[row].split("")
      // 做选择
      letter[col] = "Q"
      board[row] = letter.join("")
      // 递归
      backStack(board.slice(),row+1)
      //撤销
      letter[col] = "."
      board[row] = letter.join("")
    }

  }
  // 题意：左上方，右上方，本列不允许出现皇后
  function isVaild(board,row,col){
    // 本列
    for(let i =0;i < n;i++){
      if(board[i][col] === 'Q'){
        return false
      }
    }
    // 左上方
    for(let i = row-1,j = col-1;i>=0&&j>=0;i--,j--){
      if(board[i][j] === 'Q'){
        return false
      }
    }
    // 右上方
    for(let i = row-1,j=col+1;i>=0&&j<n;i--,j++){
      if(board[i][j] === 'Q'){
        return false
      }
    }
    return true
  }
/* 初始化棋盘 ，Array(4).fill(".".repeat(4))其实就是 声明长度为4的数组然后 填满4个点的字符串的元素
* ===>["....","....","....","...."]
*/
  backStack(Array(4).fill(".".repeat(4)),0)
  return res
};
```

**总结：**

凡是遇到有可寻的路径也有死路的问题都可以往回溯算法想，遇到题目先把三要素(选择列表，路径，结束条件)写出来，然后套用模板解题

## BFS解题模板

[完整地址](https://labuladong.gitee.io/algo/%E7%AE%97%E6%B3%95%E6%80%9D%E7%BB%B4%E7%B3%BB%E5%88%97/BFS%E6%A1%86%E6%9E%B6.html)

[二叉树的最小深度](https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/)

BFS是用来求最短路径的，但代价就是空间复杂度比 DFS 大很多

**常见使用BFS场景**


![](https://image.yangxiansheng.top/img/20201223152010.png?imglist)

**解题模板**

```java
// 计算从起点 start 到终点 target 的最近距离
int BFS(Node start, Node target) {
    Queue<Node> q; // 核心数据结构
    Set<Node> visited; // 避免走回头路

    q.offer(start); // 将起点加入队列
    visited.add(start);
    int step = 0; // 记录扩散的步数

    while (q not empty) {
        int sz = q.size();
        /* 将当前队列中的所有节点向四周扩散 */
        for (int i = 0; i < sz; i++) {
            Node cur = q.poll();
            /* 划重点：这里判断是否到达终点 */
            if (cur is target)
                return step;
            /* 将 cur 的相邻节点加入队列 */
            for (Node x : cur.adj())
                if (x not in visited) {
                    q.offer(x);
                    visited.add(x);
                }
        }
        /* 划重点：更新步数在这里 */
        step++;
    }
}
```

可转换为JS版本

```js
bfs = (root,target)=>{
  let q = [[root,1]] //初始化队列
  while(q.length){
    let [n,level] = q.shift()
    if(n === target){
      return level
    }
    if(n.left){
      q.push([n.left,level+1])
    }
    if(n.right){
      q.push([n.right,level+1])
    }
  }
}
```

## 二分查找解题模板

[完整地址](https://labuladong.gitee.io/algo/%E7%AE%97%E6%B3%95%E6%80%9D%E7%BB%B4%E7%B3%BB%E5%88%97/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E8%AF%A6%E8%A7%A3.html)

[二分查找](https://leetcode-cn.com/problems/binary-search/)

[在排序数组中查找元素的第一个和最后一个位置](https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/)

### 常规

首先常规的二分查找不用多说直接上

```js
function binarySearch(arr,item){
  let low = 0
  let high = arr.length-1
  while(low <= high){
    let mid = Math.floor((low + high)/2)
    let Element = arr[mid]
    if(Element === item){
      return mid
    }else if(Element > item){
      high = mid -1
    }else if(Element < item){
      low = mid + 1
    }
  }
  return -1
}
```
### 数组边界问题

但是这个常规的二分查找无法处理一下情形

> 输入 [1,2,3,3,4] ,3

这个时候我们在搜索的如果中间位元素等于搜索元素就不能直接返回，要分两种情况了。
一句话就是，寻找数组左侧第一位，就要缩小右侧边界范围，寻找右侧第一位，就要缩小左侧边界范围,然后检查数组越界也需要格外注意

**左侧边界查找**：`[left,right)`, **当`nums[mid] == target`时不要立即返回而要收紧右侧边界(`high = mid -1`)以锁定左侧边界**

```js
function leftBoundSearch(arr,item){
  let low = 0
  let high = arr.length-1
  while(low <= high){
    // 切记 取值一定要定义在里面，不然会报错
    let mid = Math.floor((low + high)/2)
    let Element = arr[mid]
    if(Element === item){
      high = mid - 1
    }else if(Element > item){
      high = mid -1
    }else if(Element < item){
      low = mid + 1
    }
  }
  // 检查数组越界
  if(low >= arr.length || arr[left] !== item){
    return -1
  }
  return left
}

```


**右侧边界查找**：(left,right],**当`nums[mid] == target`时不要立即返回而要收紧左侧边界(`low = mid +1`)以锁定右侧边界**

```js
function rightBoundSearch(arr,item){
  let low = 0
  let high = arr.length-1
  while(low <= high){
    let mid = Math.floor((low + high)/2)
    let Element = arr[mid]
    if(Element === item){
      low = mid + 1
    }else if(Element > item){
      high = mid -1
    }else if(Element < item){
      low = mid + 1
    }
  }
  // 检查数组越界
  if( high < 0|| arr[right] !== item){
    return -1
  }
  return right
}

```

## 双指针技巧总结

需要注意的是链表里面的值计算有一定的技巧，比如设置head变量，它代表整个链表。

![](https://image.yangxiansheng.top/img/20201223202202.png?imglist)

双指针技巧再分为两类，一类是「快慢指针」，一类是「左右指针」。**前者解决主要解决链表中的问题**，比如典型的判定链表中是否包含环；**后者主要解决数组（或者字符串）中的问题**，比如二分查找。

### 快慢指针

快满指针都初始化为 `head` 头结点，解决链表问题,如果没有成环则代表 `fast === null`,保证快慢指针能走下去的条件是 `fast && fast.next`

1. 判定链表中是否含有环

**一快一慢指针遍历，相遇即成环**

```js
var cicleList = (head)=>{
  let fast = head
  let slow = head
  while(fast && fast.next){
    fast = fast.next.next
    slow = slow.next
    if(fast === slow){
      return true
    }
  }
  return false
}
```

2. 已知链表中含有环，返回这个环的起始位置

![](https://image.yangxiansheng.top/img/20201223204549.png?imglist)

**快慢指针先跑一圈，成环之后，再让快慢指针匀速跑，相遇点就是成环的第一个入环点,记得考虑第一次未成环情况**

理由：fast指针走2k步，slow指针走k步。指针从相遇点到入环点和第一次成环相遇点到入环点的距离相同

![](https://image.yangxiansheng.top/img/20201223205236.png?imglist)


```js
var detectCycle = function(head) {
    // 首先快指针和满指针先成环，跑一圈
    let fast = head
    let slow = head
    while(fast && fast.next){
        fast = fast.next.next
        slow = slow.next
        if(fast === slow){
            break
        }
    }
    // 如果没有成环
    if(!fast || !fast.next){
        return null
    }
    // 然后再匀速跑,再次相遇就是第一个入环的节点
    slow = head
    while(fast !== slow){
        fast = fast.next
        slow = slow.next
    }
    return slow

};
```

3. 寻找链表的中点

![](https://image.yangxiansheng.top/img/20201223210616.png?imglist)

**一快一慢指针遍历，指针遍历完成时，慢指针就是中点**

```js
var middleNode = function(head) {
    let fast = head
    let slow = head
    while(fast && fast.next){
        fast = fast.next.next
        slow = slow.next
    }
    return slow

};
```

4. 寻找链表的倒数第 `n` 个元素

![](https://image.yangxiansheng.top/img/cc43daa8cbb755373ce4c5cd10c44066dc770a34a6d2913a52f8047cbf5e6e56-file_1559548337458.gif?imglist)

**先让快指针走n步，然后两个指针同时遍历，到最后慢指针的下一个节点就是删除的节点，记得考虑一开始头指针就是要删除的节点，这时返回`head.next`**

```js
var removeNthFromEnd = function(head, n) {
    let fast = head
    let slow = head
    // 快指针先走n步
    for(let i=0;i<n;i++){
        fast = fast.next
    }
    // 如果删除的倒数第n个节点是头结点，直接返回下一节点
    if(fast === null){
        return head.next
    }
    // 快指针走完之后双指针匀速前行，到头则slow.next就是要删除的倒数第n个节点
    while(fast && fast.next){
        fast = fast.next
        slow = slow.next
    }
    slow.next = slow.next.next
    return head
    
};
```

### 左右指针

左右指针问题一般是**处理二分查找(数组或者字符串)**

1. 二分查找

2. 两数之和 II - 输入有序数组

![](https://image.yangxiansheng.top/img/20201223214059.png?imglist)

二分法
```js
var twoSum = function(numbers, target) {
    let left = 0
    let right = numbers.length -1
    while(left < right){
        let sum = numbers[left] + numbers[right]
        if(sum === target){
            return [left + 1, right + 1]
        }else if(sum < target){
            // 让sum大点
            left ++
        }else if(sum > target){
            // 让sum小点
            right --
        }
    }
    return [-1,-1]
};
```

3. 反转数组

![](https://image.yangxiansheng.top/img/20201223215911.png?imglist)

二分法，一前一后遍历更换值

```js
  var reverseString = function(s) {
      let left = 0
      let right = s.length - 1
      while(left < right){
          const temp = s[left]
          s[left] = s[right]
          s[right] = temp
          left++  
          right--
      }
  };
```


4. 滑动窗口


## 滑动窗口解题模板

