# 事件循环机制

## 浏览器

### 阐述
JS脚本scrpit包含异步任务和同步任务，首先同步任务在主线程上执行，当同步任务执行完成后，JS将当前执行栈清空。然后开始执行异步任务，异步任务分为红任务和微任务，异步任务会放入任务队列当中，宏任务放入宏任务队列，微任务会放入微任务队列。

同步任务执行完之后，先去微任务队列拿出一个微任务，如果执行过程产生了微任务或者宏任务，会将他们放入各自的任务队列。循环往复，直到把微任务队列清空。

紧接着会从宏任务队列中拿出一个宏任务，执行过程中若产生了微任务，首先会把微任务放入微任务队列，然后等这个宏任务执行完成之后就会去执行这个微任务。如果没有产生微任务就继续执行下一个宏任务，循环往复，直到清空宏任务。

在宏任务执行完成前的一刻，渲染进程会触发GUI和dom的渲染。

### 例题分析

```js
console.log('script start');

setTimeout(function() {
  console.log('setTimeout');
}, 0);

Promise.resolve().then(function() {
  console.log('promise1');
}).then(function() {
  console.log('promise2');
});
console.log('script end');
```

<details>
<summary>查看答案</summary>

```js
执行栈: script start script end
微任务队列: promise1 promise2
宏任务队列: setTimeout 
```
</details>

```js
console.log('script start')

async function async1() {
  await async2()
  console.log('async1 end')
}
async function async2() {
  console.log('async2 end') 
}
async1()

setTimeout(function() {
  console.log('setTimeout')
}, 0)

new Promise(resolve => {
  console.log('Promise')
  resolve()
})
  .then(function() {
    console.log('promise1')
  })
  .then(function() {
    console.log('promise2')
  })

console.log('script end')

```

<details>
<summary>查看答案</summary>

```js
分析: async 和 await 代码转换为

async function async1() {
  await async2()
  console.log('async1 end')
}
===》

function f() {
  return RESOLVE(p).then(() => {
    console.log('ok')
  })
}

首先执行同步任务

- script start
- async2 end
- Promise (promise的构造函数将其视为同步函数)
- script end
然后将webapi将异步任务队列分别丢进微任务队列和宏任务队列

首先执行微任务，执行微任务队列前会去检查当前任务队列是否存在在微任务队列或执行栈任务，有就放入各自队列，直到清空微任务

- async1 end
- promise1
- promise2
然后执行宏任务，执行宏任务前会去检查当前宏任务的微任务队列，若存在则一次性执行完，不存在则执行宏任务。宏任务执行完成，渲染进程触发GUI，dom渲染。
依次循环

分析: async 和 await 代码转换为

async function async1() {
  await async2()
  console.log('async1 end')
}
===》

function f() {
  return RESOLVE(p).then(() => {
    console.log('ok')
  })
}

首先执行同步任务

- script start
- async2 end
- Promise (promise的构造函数将其视为同步函数)
- script end
然后将webapi将异步任务队列分别丢进微任务队列和宏任务队列

首先执行微任务，执行微任务队列前会去检查当前任务队列是否存在在微任务队列或执行栈任务，有就放入各自队列，直到清空微任务

- async1 end
- promise1
- promise2
- setTimeout
然后执行宏任务，执行宏任务前会去检查当前宏任务的微任务队列，若存在则一次性执行完，不存在则执行宏任务。宏任务执行完成，渲染进程触发GUI，dom渲染。
依次循环
- setTimeout

```
</details>





## NodeJS 


## 例题

### setTimeout、setImmediate() 和 process.nextTick()

setTimeout为在指定时间之后就执行
setImmediate设计是当前轮询阶段完成后就立即执行
如果放在同一个I/O循环内使用，setImmediate总是被优先调用，他的优势是如果在I/O周期内被调度的话，他会在所有定时器之前执行。他执行的方式是当前任务队列的尾部
process.nextTick触发的是在当前执行栈的尾部，下一次事件循环之前，总是在异步之前。

为什么要使用process.nextTick()，因为可以允许用户处理错误，或者是在事件循环继续之前重试请求
