
## 执行上下文

JS 代码在遇到一个函数执行时,会进入`预编译`状态，生成执行上下文,然后再执行。做题目谨记解题的几大过程，此类题目就迎刃而解，变得很简单

### 预编译之前需要了解的

```js
a() // a
function a(){
  console.log('a')
}
```
```js
console.log(a) //undefined
var a = 2 // 变量声明 + 变量赋值
```

口诀:

- 函数声明整体提升(**函数声明永远提升到js文件最前面**)
- 变量 声明提升
- 任何变量,**如果变量未经声明就赋值,归全局所有**

```js
function a(){
  var b = c = 20
  console.log(window.c)
  console.log(window.b) 
}
a() //c未声明就赋值归全局所有 20 undefined
```
- **一切声明的全局变量,就归 window 所有**(可以理解为 window 是全局的域对象，定义变量b，相当于往仓库里添加 b)

```js
// 全局范围内 

var b = 10
console.log(b) //10
console.log(window.b)//10
```


### 预编译过程

#### 函数预编译

预编译发生在函数执行的前一刻

1. 创建 AO 对象  --- 执行期上下文对象(Activation Object)
2. 找**形参**和**变量声明**，将变量和形参名作为 AO 属性名,值为 undefined (变量提升)
3. **将实参值和形参相统一**
4. 在函数里面找**函数声明**,将函数名作为属性值挂上，值为函数体

```js
function fn(a) {
  console.log(a)
  var a = 123
  console.log(a)
  function a() {}
  console.log(a)
  var b = function() 
  console.log(b)
  function d(){}
}
fn(1)

预编译环节

1. 创建 AO 对象（执行期上下文）
2. AO{
  a: undefined,
  b: undefined

}
3. AO{
  a: 1，
  b: undefined
}，
4. AO{
  a: func a(),
  b: undefined,
  d: func d()
}

预编译完成之后 AO对象相当于电脑里的东西，然后去执行代码更新AO

1. 打印 func a()
2. a 被赋值 123,打印 123
3. function a() 已经被提升，跳过
4. b 被赋值 fun() 打印 fun()

```

#### 全局预编译

全局预编译过程相比函数预编译过程**少了第三步**，没有参数的概念。**如果又存在全局又存在函数则首先考虑全局在考虑函数预编译**。**执行代码过程中如果AO有该变量，就先取AO的，没有再去GO中取。**

1. 创建 GO 全局对象(GO === window)，Global Object
2. 寻找声明变量，赋值undefined
3. 寻找函数声明，函数名作为属性名，函数体作为值

```js
console.log(test)
function test(test) {
  console.log(test)
  var test = 234
  console.log(test)
  function test() {}
}
test(1)
var test = 123

全局预编译

1. GO {
  test: function test()
}

执行过程:
1. 打印function test()
2. 跳过声明函数

执行函数test(1)前一刻，进入函数预编译

1. AO{
  test:undefined
}
2. AO{
  test:1
}
3. AO{
  test:func
}

执行过程:
1. 打印func
2. AO{
  test:234
}
3. 打印 234
```

> 遇到此问题口诀: 1. 首先处理全局对象 2. 处理函数执行前预编译，也就是分析出执行上下文对象 3. 执行期间赋值


### 例题


```js
function test(a,b) {
  console.log(a)
  c = 0
  var c
  a = 3
  b = 2
  console.log(b)
  function b(){}
  function d(){}
  console.log(b)
}
test(1)
```
<details>
<summary>查看答案</summary>
1、2、2

```markdown
按照上述步骤分析:

1. AO{
    a:undefined,
    b:undefined,
    c:undefined
  }
2. AO{
    a:1,
    b:undefined,
    c:undefined
  }
3. AO{
    a:1,
    b:func(),
    c:undefined,
    d:func()
  }

代码执行: 
1. 打印1
2. AO{
      a:3,
      b:2,
      c:9,
      d:func
    }
3. 打印2
4. 打印2
5. 结果 1，2，2

```
</details>
<br/>

```js
function test(a,b) {
  console.log(a)
  console.log(b)
  var b = 234
  console.log(b)
  a = 123
  console.log(a)
  function a(){}
  var a
  b = 234
  var b = function(){}
  console.log(a)
  console.log(b)
}
test(1)
```
<details>
<summary>查看答案</summary>
func,undefined,234,123,123,func

```markdown
1. AO{
  a:undefined,
  b:undefined,
}
2. AO{
  a: 1,
  b: undefined
}
3. AO{
  a: func()
  b:undefined
}

执行阶段:
1. 打印func
2. 打印undefined
3. AO{
  a: 1,
  b:234
}
4. 打印234
5. AO{
  a:123,
  b:234
}
6. 打印123
7. AO{
  a:123,
  b:func
}
8. 打印123，
9. 打印func
```
</details>
<br/>

```js
global =  100
function fn (){
  console.log(global)
  global = 200
  console.log(global)
  var global = 300
  console.log(global)
}
fn()
var global
```
<details>
<summary>查看答案</summary>
undefined,200,300

```markdown
1. 首先是GO{
  global:undefined，
}
2. GO{
  global:undefined,
  fn:function
}
执行过程： 
1. GO{
  global:100,
  fn:function
}

执行fn函数前一刻，进入函数预编译

1. AO{
  global:undefined
}
```
执行过程:
1. 打印undefined
2. AO{
  global:200
}
3. 打印200
4. AO{
  global:300
}
5. 打印300
</details>
<br/>

```js
function test(){
  console.log(b)
  if(a){
    var b = 100
  }
  console.log(b) 
  c = 234
  console.log(c)
}
var a
test()
a = 10
console.log(c)
```

<details>
<summary>查看答案</summary>
undefined、undefined、234、234

```markdown
1. GO{
  a : undefined
}

执行： 执行过程中执行test()之前进入函数预编译

1. 此处不需要管任何其他干扰因素(if for),上面的四个步骤就是真理
AO{
  b: undefined
}
下面都是全局执行的第一步，只不过是函数的内部执行
·························
  函数执行过程:
  1. 打印undefined
  2. if条件不成立
  3. 打印undefined
  4. 注意c是未经声明就赋值的变量。给GO

  GO{
    a:undefined,
    c: 234
  }
  5. 打印234
···························
```

2. GO{
  a: 10,
  c: 234
}
3. 打印 234
</details>
<br/>

```js
function bar(){
return foo
foo=10
function foo(){}
var foo =11

}
console.log(bar)
console.log(bar())
```

<details>
<summary>查看答案</summary>

![](https://image.yangxiansheng.top/img/20201215205111.png?imglist)

过程也很简单，就是打印前一刻进入函数预编译，但是预编译直接return了，AO里面的foo就是个function，然后继续执行全局代码打印出function，第一个bar是全局GO中的属性，第二个是执行结果
</details>


## 作用域和作用域链


## 闭包

![](https://image.yangxiansheng.top/img/20201215132539.png?imglist)

## 立即执行函数
