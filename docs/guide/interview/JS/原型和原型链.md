# 原型和应用

## 原型和原型链

**原型的定义:**

原型是 function 对象的一个属性，它定义了构造函数制造出来的对象的公有祖先，**通过该构造函数产生的对象，可以继承该原型的属性和方法**，原型其实就是一个对象。

```js
可能第一眼看定义是懵的，别急，逐行解释

首先定义一个构造函数(大写驼峰式) Person
function Person(){

}

然后通过构造函数制造一个对象

var person = new Person()

然后原型怎么写呢 
Person.prototype = {} // 天生就有

按照定义: 他定义了构造函数只找出来的对象的公有祖先,也就是说这个 `prototype` 对象是 person的祖先，
并且能够使用里面的属性和方法

Person.prototype.name = "deng"
console.log(person.name) // deng
虽然 person对象上没有该属性，但是祖先有，拿过来用，这就是全部过程
```

**如何理解__proto__**

```js
Person.prototype.name = 'abc'
function Person(){}
var obj = {
  name:"sunny"
}
var person = new Person()
person.__proto__ = obj
console.log(person.name) //sunny
```

```js
1.首先理解这个问题需要清楚person是怎么知道除了自身属性没有
然后去查找祖先Person的原型Prototype的:

  当使用new操作符时，其实就是在构造函数内部定义了一个this，
  然后this下面有很多属性，其中有一个__proto__隐式原型属性，
  它的值就是指向Person的原型也就是Person.prototype。
  这也是person怎么查找祖先的根本

  var person = new Person()

  等价于

  function Person(){
    var this = {
      ___proto__: Person.prototype
    }
  }

  这也是person如何修改Person的原型的唯一途径

2. person查找变量，首先找自己身上的，没有就通过__proto__去查找祖先的属性
```

**原型的应用:**

1. 利用原型的特点和概念，可以提取公有属性

```js
function Person(name,age){
  this.sex = 'male'
  this.level = 2
  this.name = name
  this.age = age
}

var person1 = new Person // 想要person上有sex,level，每次都会执行两条语句，
//造成了代码的冗余，利用原型提取公共属性

Person.prototype.sex = "male"
Person.prototype.level = 2
// 这样公共属性就不用每次都去赋值，一次就好了
```
2. 对象查找该对象的构造器是什么

```js
function Car() {}

var car = new Car()

car.constructor == Car // true

console.log(car.constructor) // function Car(){}

因为刚开始构造函数的prototype里面就保存了constructor

Car.prototype={
  constructor:func
}

car继承了祖先方法和属性，所以调用自然可以找到该构造器是什么
```

3. Object.create() 参数必须是一个原型对象，创建一个有该原型对象的对象

```js
var obj1 = {name:"surry"}
var obj = Object.create(obj1)

// obj.name = surry
```


**原型链的定义**

每个显式原型下也有一个隐式原型，指向规则和上面一样。**在每一层首先寻找自身的属性或方法,如果没有通过隐式原型去找上一层的显示原型的方法,依次形成一个链**

原型链的最高层`Object`的显示原型拥有`toString`和`hasOwnProperty`方法和自身隐式原型指向null

![](https://image.yangxiansheng.top/img/20201216225800.png?imglist)


## JS 原型链和实现继承的各种方式和优点


