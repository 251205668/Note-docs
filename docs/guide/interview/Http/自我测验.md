## 12.21网络

1. TCP面向连接，面向字节流，有状态，具备拥塞控制能力，可以保证可靠交付，点对点传播，有序
2. UDP无连接，面向数据包，无状态，不能保证可靠交付，不具备拥塞控制能力，广播、多波，无序

1. HTTP建立在应用层，TCP建立在传输层协议
2. HTTP是建立在TCP的基础的
3. HTTP协议包含了数据的分发，TCP协议只负责连接

HTTP请求报文： 请求行、请求头、空行、请求数据

请求行是由：请求方法字段+URL+HTTP协议版本

请求头：每次发送的请求头都会告诉服务器一些客户端的信息

1.user-agent: 请求的浏览器类型

 2.accept： 客户端能识别的内容列表

3.  host;主机地址
4. content-type,代表请求体的MIME类型，常见有：application/json

响应报文： 状态行、响应头、空行、响应正文

1. get请求会被浏览器缓存，请求体的长度有限，浏览器进行回退操作时无害的，一般请求都不会携带请求体，发送一个TCP数据包
2. POST是安全的，编码方式多样，POST请求可以发送较大的数据，浏览在回退操作之后会再次发送一次请求，一般POST请求会携带请求体，POST发送两个TCP数据包

1. 客户端向服务端发送SYN连接包，代表我要向你发起连接了
2. 服务端接收到了客户端的SYN包直接，确认建立连接，将自己的SYN包和确认包ACK发送给客户端
3. 为了检验双方都有收发能力，客户端再次向服务端发送ACK确认包，表示三次握手成功

否，如果在没有缓存的情况下，请求头设置了`connnection:keep-alive`，第二次请求之后就不会三次握手了

第二次和第二次是不可以的，第三次双方都已经进入establish状态，这个时候是可以发送数据的

DNS：

DNS是域名转为为IP地址服务，简称域名系统，DNS协议依赖UDP协议，涉及到的端口号是53

1. 本地输入一个IP地址，电脑向本地DNS服务器发送一个请求
2. 本地DNS服务器如果有缓存，就直接返回结果，如果没有就像跟服务器发送请求
3. 跟服务器上如果也没有域名和IP地址的关系，就会告诉本地继续要域服务器发送请求查找，并且返回域服务器的地址
4. 本地DNS服务器向域服务器发送请求，返回解析的域名服务器的IP地址
5. 本地DNS向域名服务器发送请求，返回IP和域名关系
6. 本地DNS服务器将整个IP地址返回给电脑，然后缓存备份，以便下次使用

因为TCP协议会有连接时延

- 获取一个IP地址，向多个域名服务器发送请求，这样每次请求都会产生连接时延，这样会造成堵塞
- 本地获取IP地址，通常是在浏览器输入地址，然后发送情求，如果使用TCP的话，浏览器请求页面会很慢

CND：简称内容分发网络，是一组分布在不同的地理位置的web服务器

CDN解决了什么：由于服务器距离越远，延迟越高，CDN就是为了解决这一现状，从而缩短请求时间

CDN原理

1. 浏览器输入IP地址，向本地DNS服务器发送请求
2. 本地DNS服务器会依次向跟服务器，顶级域名服务器，权限服务器发送请求，获取到全局负载均衡的IP地址
3. 本地DNS系统会向全局负载均衡系统发送请求，获取到最近的本地负载均衡系统的IP地址
4. 本地DNS会向本地负载均衡系统发送请求
5. 本地负载均衡系统会返回一个最有效的缓存服务器地址给浏览器
6. 本地DNS向缓存服务器发送请求
7. 如果缓存服务器上有该ip的记录，会直接返还资源给浏览器，否则会请求原服务器，返还资源



Keep-alive ：持续连接，高效复用模式，持续连接能够维持客户端和服务端的持久连接，高效指的是，当浏览器再次向服务端发送请求时，不会去从新创建TCP连接，而是直接复用同一个连接，减少开销

TCP侧重于持续连接，会不定时的发送一个心跳包检测双方是否断开连接，如果不这样样做会对服务器资源影响很大

HTTP侧重于复用

URL：协议+IP地址/域名+地址+端口号+参数+锚点

对头阻塞：每个HTTP请求，都会任务队列的形式进行串行执行，每当对头请求过慢，就会阻塞后续请求操作

- 并发连接
- 域名分片

## 12.22 网络

1. 灵活可扩展性：主要体现在两个方面，第一是格式没有很大的限制，比如仅定义了部分语法格式限制，如单词用空格隔开，字段用空行隔开
2. 可靠数据：此特点继承与TCP协议的保证可靠交付的特点
3. 请求-应答：一方发送，一方响应，当然这里不仅仅局限于客户端和服务端通信，比如一个代理服务器也充当着请求方的角色
4. 无状态：这里的状态代表通信过程中的上下文信息，http请求是相对独立的，默认不会保存状态信息

HTTP2.0

1. 单位使用二进制，健壮性更强，以前使用纯文本发送，健壮性不够强
2. 多路复用：多个TCP连接形成多个不同的流，相应结果分为不同的帧，不同的流里面的帧交错发送，解决了TCP连接数量多，TCP连接慢的问题，这样每个域名只需要一个连接即可
3. 压缩消息头：避免了请求头重复传输，缩小了传输的大小
4. 采用服务端推送方式：浏览器请求时，服务端会根据请求将相关资源返回浏览器，浏览器不需要重复发送请求
5. 设置请求优先级：解决阻塞问题

HTTP1.1

1. 缓存处理新增cache-Control，if-none-match等缓存头处理
2. 长连接，一个TCP连接中可以发送多个请求和响应

HTTP1.x版本问题

1. 传输过程中，所有内容都是明文，客户端和服务端无法验证对方的身份和无法保证数据的安全性
2. HTTP1.X虽然可以服用TCP连接，但是每个TCP连接中可以有不同的请求，并且请求是按一定的次序的，会造成一定的阻塞
3. HTTP1.1设置keep-alive，虽然达到了持久连接，高效复用的效果，但是会消耗大量的资源，比如单文件请求之后，浏览器和服务器会有一个较长时间的不必要连接时长

HTTP缓存分为： 强缓存+ 协商缓存

浏览器第一次发送请求时，客户端会向服务端发送请求，浏览器缓存，服务器会通过last-modified字段将最后修改时间发送给客户端。另外还会发送一个etag(文件内容的唯一表示缓存)给客户端

浏览器再次发送请求：

1. 浏览器获取资源一般会取出资源缓存的请求头header部分，该header部分有两个字段：cache-control,expires。如果缓存有效，则直接使用本地缓存，如果过期则命中协商缓存，这一过程没有和服务器进行通信
2. 如果已经过期，浏览器会携带上一次请求资源的header字段重新发送请求。比如客户端会通过if-none-match将上一次请求服务器发送过来的etag发送给服务器，然后服务器回去比对自己的etag，如果相同，则将if-none-match设为false，状态设为304，直接使用本地缓存，如果不相同，则设置为true，发送和HTTP请求一致的请求；客户端还会通过if-modified-since字段将上一次服务器返回的页面修改时间发送给服务器，然后服务器会根据这个时间判断当前页面是否是最新的，如果是最新的，则直接使用本地缓存，如果不是最新的则换回最新的内容



协商缓存：etag+lastModified

强缓存：cache-control，expires



缓存的几种场景：

1、一般情况下强缓存搭配协商缓存

2、不需要缓存的资源设置cache-control:no-store

3、频繁更新资源设置cache-control：no-cache，但是每次都回去检查该资源是否更新

4、代码，设置cache-control：max-age