
复习完所有的知识点之后，刷一下这篇文章[https://juejin.im/post/6844904100035821575](https://juejin.im/post/6844904100035821575)


[https://juejin.im/post/6844904070889603085](https://juejin.im/post/6844904070889603085)


https://www.cxymsg.com/guide/http.html#http%E6%9C%89%E5%93%AA%E4%BA%9B%E6%96%B9%E6%B3%95%EF%BC%9F

## 请简述TCP\UDP的区别
TCP:

面向连接
面向字节流
有状态
保证可靠交付
具备拥塞控制
点对点传播
有序

UDP:

无连接
面向数据报
无状态
不保证可靠交付
不具备拥塞控制
广播、多播
无序

## HTTP和TCP的关系

http是应用层，tcp是传输层
http是基于tcp的基础上实现的
tcp只是单纯的进行连接，http是会进行收发数据

## get和post的区别

- get 会被浏览器缓存，请求长度受限，会被历史保存记录，浏览器回退时候是无害的，一般不带请求体，发送一个TCP数据包。

- post 更安全，更多编码类型，可以发大数据，浏览器回退的时候会再次提交请求，一般带有请求体，发送两个TCP数据包(保证网络较差完整性)


## HTTP 报文

**请求报文**

一个 HTTP 请求报文由**请求行（request line）**、**请求头（header）**、**空行**和**请求数据** 4个部分组成。

**请求行**

包括请求方法字段、URL 字段和 HTTP 协议版本，如：GET /index.html HTTP/1.1

**请求头**

请求头由关键字 / 值组成，每行一对，关键字和值用英文冒号隔开

请求头部通知服务器有关于客户端请求的信息，典型的请求头有：

*   User-Agent：产生请求的浏览器类型
*   Accept：客户端可识别的内容类型列表
*   Host：请求的主机名，允许多个域名同处于一个 IP 地址，即虚拟主机
*   Content-Type：请求体的 MIME 类型（用于 POST 和 PUT 请求中），如：`Content-Type:application/x-www-form-urlencoded`

**空行**

最后一个请求头之后是空行，发送回车符和换行符，通知服务器以下不再有请求头

**请求数据**

请求数据不在 get 方法中使用，而是 post 方法中使用。post 方法适用于需要客户填写表单的场合，与请求数据相关的最常使用的请求头是 Content-Type 和 Content-Length



## 响应报文

响应报文由**状态行**、**响应头**、**空行**、**响应正文** 组成

## 讲一下三次握手？

SYN: 同步序号，表示请求建立连接，设置序列号字段初始值，SYN=1

ACK: ACK=1 确认号有效，ACK=0，确认号无效

ack: 确认号，序列号seq是每个字节的第一位，而确认号希望接受到下一个字节的编号
ack=上次一确认号+1

seq: 字节的第一位编号，序列号，随机生成

FIN：希望断开连接

![](https://image.yangxiansheng.top/img/20200906213917.png?imagelist)

用自己的话来讲:

1. 客户端请求建立连接，发送`SYN`(seql =x)包，服务端进入待确认状态
2. 服务端接受到`SYN`包后，确认连接，发送`ACK`包(ack = x+1),并发送自己的`SYN`包给服务端
3. 客户端接收到服务端发送的`SYN`包和`ACK`包之后，发送`ACK`确认包，发送完成之后客户端和服务端建立连接，表示三次握手成功

**为什么是三次握手**:

保证安全可靠连接

两次握手过程，只有客户端知道接受和发送的能力，**但是服务端不知道客户端能不能收到自己的信息，所以最后一次需要客户端发送ACK确认包**。服务端就知道了客户端能够接受自己的信息。

## 讲一下四次握手？

![](https://image.yangxiansheng.top/img/20200906215734.png?imagelist)

1. 客户端发送方`FIN`包给服务端，此过程是告诉服务端我要断开连接了
2. 服务端接受到了`FIN`，然后发送`ACK`确认包给客户端，告诉客户端我已经收到了，我需要准备
3. 服务端发送`FIN`断开连接包给客户端，表示断开连接准备好了
4. 客户端接收到了`FIN`，发送`ACK`给服务端，正式断开连接

![](https://image.yangxiansheng.top/img/20201207122741.png?imglist)

## 为什么建立是3次握手，而关闭是4次挥手呢？

因为建立连接的时候，客户端接受的是syn + ack包。而关闭的时候，服务端接受fin后，客户端仅仅是不再发送数据，但是还是可以接收数据的。服务端此时可以选择立刻关闭连接，或者再发送一些数据之后，再发送fin包来关闭连接。因此fin与ack包一般都会分开发送。


## TCP三次握手中可以传输数据吗

第一次第二次不可以，因为很容易被人攻击，而第三次握手已经进入establish状态了，已经确认双方的收发能力，可以传输

## 是否每一次请求都会三次握手

如果没有缓存的情况下，请求头设置connection:keep-alive则可以不重新握手

## HTTP协议的特点


- **灵活可扩展** 主要体现在两个方面。一个是语义上的自由，只规定了基本格式，比如空格分隔单词，换行分隔字段，其他的各个部分都没有严格的语法限制。另一个是传输形式的多样性，不仅仅可以传输文本，还能传输图片、视频等任意数据，非常方便。


- **可靠传输** HTTP 基于 TCP/IP，因此把这一特性继承了下来。这属于 TCP 的特性，不具体介绍了。


- **请求-应答** 也就是一发一收、有来有回， 当然这个请求方和应答方不单单指客户端和服务器之间，如果某台服务器作为代理来连接后端的服务端，那么这台服务器也会扮演请求方的角色。


- **无状态** 这里的状态是指通信过程的上下文信息，而每次 http 请求都是独立、无关的，默认不需要保留状态信息


## HTTP协议的缺点

- **「无状态」**，有时候，需要保存信息，比如像购物系统，需要保留下顾客信息等等，另外一方面，有时候，无状态也会减少网络开销，比如类似直播行业这样子等，这个还是分场景来说。

- **「明文传输」**，即协议里的报文(主要指的是头部)不使用二进制数据，而是文本形式。这让HTTP的报文信息暴露给了外界，给攻击者带来了便利。

- **「队头阻塞」**，当http开启长连接时，共用一个TCP连接，当某个请求时间过长时，其他的请求只能处于阻塞状态，这就是队头阻塞问题。




## HTTP2.0 与 HTTP1.1

HTTP2.0

- **HTTP2.0基本单位为二进制**，以往是采用文本形式，健壮性不是很好，现在采用二进制格式，更方便更健壮

- HTTP2.0的**多路复用**，把多个请求当做多个流，请求响应数据分成多个帧，不同流中的帧交错发送，解决了TCP连接数量多，TCP连接慢，所以对于同一个域名只用创建一个连接就可以了

- HTTP2.0**压缩消息头**，避免了重复请求头的传输，又减少了传输的大小

- HTTP2.0**服务端推送**，浏览器发送请求后，服务端会主动发送与这个请求相关的资源，之后浏览器就不用再次发送后续的请求了。

- HTTP2.0可以**设置请求优先级**，可以按照优先级来解决阻塞的问题

HTTP1.1

- 缓存处理新增etag、if-none-match之类的缓存头来控制缓存
- 长连接，可以在TCP连接上发送多个请求和响应

HTTP1.x版本问题

- 在传输数据过程中，所有内容都是明文，客户端和服务器端都无法验证对方的身份，无法保证数据的安全性。

- HTTP/1.1 版本默认允许复用TCP连接，但是在同一个TCP连接里，所有数据通信是按次序进行的，服务器通常在处理完一个回应后，才会继续去处理下一个，这样子就会造成队头阻塞。

- http/1.x 版本支持Keep-alive，用此方案来弥补创建多次连接产生的延迟，但是同样会给服务器带来压力，并且的话，对于单文件被不断请求的服务，Keep-alive会极大影响性能，因为它在文件被请求之后还保持了不必要的连接很长时间。

## HTTP状态码

2XX 成功

- 200 OK，表示从客户端发来的请求在服务器端被正确处理 ✨
- 201 Created 请求已经被实现，而且有一个新的资源已经依据请求的需要而建立
- 202 Accepted 请求已接受，但是还没执行，不保证完成请求
- 204 No content，表示请求成功，但响应报文不含实体的主体部分
- 206 Partial Content，进行范围请求 ✨

3XX 重定向

- 301 moved permanently，永久性重定向，表示资源已被分配了新的 URL
- 302 found，临时性重定向，表示资源临时被分配了新的 URL ✨
- 303 see other，表示资源存在着另一个 URL，应使用 GET 方法丁香获取资源
- 304 not modified，表示服务器允许访问资源，但因发生请求未满足条件的情况
- 307 temporary redirect，临时重定向，和302含义相同

4XX 客户端错误

- 400 bad request，请求报文存在语法错误 ✨
- 401 unauthorized，表示发送的请求需要有通过 HTTP 认证的认证信息 ✨
- 403 forbidden，表示对请求资源的访问被服务器拒绝 ✨
- 404 not found，表示在服务器上没有找到请求的资源 ✨
- 408 Request timeout, 客户端请求超时
- 409 Confict, 请求的资源可能引起冲突

5XX 服务器错误

- 500 internal sever error，表示服务器端在执行请求时发生了错误 ✨
- 501 Not Implemented 请求超出服务器能力范围，例如服务器不支持当前请求所需要的某个功能，或者请求是服务器不支持的某个方法
- 503 service unavailable，表明服务器暂时处于超负载或正在停机维护，无法处理请求
- 505 http version not supported 服务器不支持，或者拒绝支持在请求中使用的 HTTP 版本

## DNS是如何工作的

DNS 协议提供的是一种主机名到 IP 地址的转换服务，就是我们常说的域名系统。是应用层协议，通常该协议运行在UDP协议之上，使用的是53端口号。

DNS在本地DNS服务器是如何查询的

![](https://image.yangxiansheng.top/img/20201204130726.png?imglist)

总结:

- DNS域名系统，是应用层协议，运行UDP协议之上，使用端口43。

- 查询过程，本地查询是递归查询，依次通过浏览器缓存 —>> 本地hosts文件 —>> 本地DNS解析器 —>>本地DNS服务器 —>> 其他域名服务器请求。 接下来的过程就是迭代过程。

- 「本地服务器查询是递归查询」，而「本地 DNS 服务器向其他域名服务器请求的过程是迭代查询的过程」。


## DNS 为什么使用 UDP 协议作为传输层协议？

**「DNS 使用 UDP 协议作为传输层协议的主要原因是为了避免使用 TCP 协议时造成的连接时延。」**

- 为了得到一个域名的 IP 地址，往往会向多个域名服务器查询，如果使用 TCP 协议，那么每次请求都会存在连接时延，这样使 DNS 服务变得很慢。

- 大多数的地址查询请求，都是浏览器请求页面时发出的，这样会造成网页的等待时间过长。


## CDN 原理

![](https://image.yangxiansheng.top/img/20201205164409.png?imglist)

假设通过CDN加速的域名为www.a.com，接入CDN网络，开始使用加速服务后，当终端用户（北京）发起HTTP请求时，处理流程如下：

1. 当终端用户（北京）向www.a.com下的指定资源发起请求时，首先向LDNS（本地DNS）发起域名解析请求。
2. LDNS检查缓存中是否有www.a.com的IP地址记录。如果有，则直接返回给终端用户；如果没有，则向授权DNS查询。
3. 当授权DNS解析www.a.com时，返回域名CNAME www.a.tbcdn.com对应IP地址。
4. 域名解析请求发送至阿里云DNS调度系统，并为请求分配最佳节点IP地址。
5. LDNS获取DNS返回的解析IP地址。
6. 用户获取解析IP地址。
7. 用户向获取的IP地址发起对该资源的访问请求。

总结:

- CDN的加速资源是跟域名绑定的。
- 通过域名访问资源，首先是通过DNS分查找离用户最近的CDN节点（边缘服务器）的IP
- 通过IP访问实际资源时，如果CDN上并没有缓存资源，则会到源站请求资源，并缓存到CDN节点上，这样，用户下一次访问时，该CDN节点就会有对应资源的缓存了。


## Keep-alive

当使用 Keep-Alive 模式（又称持久连接、连接重用）时，Keep-Alive功能使客户端到服 务器端的连接持续有效，当出现对服务器的后继请求时，Keep-Alive功能避免了建立或者重新建立连接。htttp1.0需要在头部加入 `Connection:Keep`,http1.1自带

为什么要使用keep-alive

keep-alive技术的创建目的，能在多次HTTP之前重用同一个TCP连接，从而减少创建/关闭多个 TCP 连接的开销（包括响应时间、CPU 资源、减少拥堵等）


## 介绍HTTP缓存策略


### HTTP的缓存过程

- 客户端向服务器发出请求，请求资源

- 服务器返回资源，并通过响应头决定缓存策略

- 客户端根据响应头的策略决定是否缓存资源（这里假设是），并将响应头与资源缓存下来

- 在客户端再次请求且命中资源的时候，此时客户端去检查上次缓存的缓存策略，根据策略的不同、是否过期等判断是直接读取本地缓存还是与服务器协商缓存

### 什么时候会触发强缓存和协商缓存

#### 强缓存

强缓存离不开两个响应头 `Expires` 与 `Cache-Control`

**Expires**：`Expires` 是http1.0提出的一个表示资源过期时间的 `header`，它描述的是一个绝对时间，由服务器返回，Expires 受限于本地时间，如果修改了本地时间，可能会造成缓存失效

`Expires: Wed, 11 May 2018 07:20:00 GMT`

**Cache-Control**: `Cache-Control` 出现于 HTTP / 1.1，优先级高于 `Expires` ,表示的是相对时间


目前主流的做法使用Cache-Control控制缓存，当Expires和Cache-Control同时存在时，优先考虑Cache-Control，当缓存资源失效了，也就是没有命中强缓存，接下来就进入协商缓存

#### 协商缓存


强缓存失效后，浏览器在请求头中携带响应的 `缓存Tag` 来向服务器发送请求，服务器根据对应的 `tag`，来决定是否使用缓存。

缓存分为两种，「Last-Modified」 和 「ETag」

**Last-Modified**

浏览器接收到后，「如果再次请求」，会在请求头中携带If-Modified-Since字段，这个字段的值也就是服务器传来的最后修改时间。

- 如果请求头中的这个值小于最后修改时间，说明是时候更新了。返回新的资源，跟常规的HTTP请求响应的流程一样。

- 否则返回304，告诉浏览器直接使用缓存

**ETag**

ETag 是服务器根据当前文件的内容，对文件生成唯一的标识,这个值就会修改，服务器通过把响应头把该字段作为「If-None-Match」这个字段的内容给浏览器。

服务器接收到「If-None-Match」后，会跟服务器上该资源的「ETag」进行比对

- 如果两者一样的话，直接返回304，告诉浏览器直接使用缓存

- 如果不一样的话，说明内容更新了，返回新的资源，跟常规的HTTP请求响应的流程一样

#### 总结

- 首先检查Cache-Control，尝鲜，看强缓存是否可用

- 如果可用的话直接使用

否则进入协商缓存，发送HTTP请求，服务器通过请求头中的If-Modified-Since或者If-None-Match字段检查资源是否更新

- 资源更新，返回资源和200状态码。

- 否则，返回304，直接告诉浏览器直接从缓存中去资源。



## HTTP请求方法

- GET: 通常用来获取资源
- HEAD: 获取资源的元信息
- POST: 提交数据，即上传数据
- PUT: 修改数据
- DELETE: 删除资源(几乎用不到)
- CONNECT: 建立连接隧道，用于代理服务器
- OPTIONS: 列出可对资源实行的请求方法，用来跨域请求
- TRACE: 追踪请求-响应的传输路径

## 五层网络协议和OSI模型

![](https://image.yangxiansheng.top/img/20201204134016.png?imglist)

![](https://image.yangxiansheng.top/img/20201204134047.png?imglist)

## options 方法有什么用？

- OPTIONS 请求与 HEAD 类似，一般也是用于客户端查看服务器的性能。

- 这个方法会请求服务器返回该资源所支持的所有 HTTP 请求方法，该方法会用'*'来代替资源名称，向服务器发送 OPTIONS 请求，可以测试服务器功能是否正常。

- JS 的 XMLHttpRequest对象进行 CORS 跨域资源共享时，对于复杂请求，就是使用 OPTIONS 方法发送嗅探请求，以判断是否有对指定资源的访问权限。


## 谈一谈你对URL理解

统一资源定位符的简称，Uniform Resource Locator，常常被称为网址，是因特网上标准的资源地址。

**通用的格式**：

scheme://host[:port]/path/…/?query#anchor

> 协议 + IP地址/域名 + 端口 + 路径 + 参数 + 锚点

URL 只能使用 ASCII 字符集来通过因特网进行发送。天天转换为有效的ASCII格式就是%CC%EC%CC%EC

## 什么是队头阻塞？

对于每一个HTTP请求而言，这些任务是会被**放入一个任务队列中串行执行**的，一旦队首任务请求太慢时，就会阻塞后面的请求处理，这就是HTTP队头阻塞问题。

**解决办法:**

并发连接: 我们知道对于一个域名而言，是允许分配多个长连接的，那么可以理解成增加了任务队列，也就是说不会导致一个任务阻塞了该任务队列的其他任务

域名分片: 我们可以在一个域名下分出多个二级域名出来，而它们最终指向的还是同一个服务器，这样子的话就可以并发处理的任务队列更多，也更好的解决了队头阻塞的问题。


## 介绍一下HTTPS和HTTP区别

- HTTP 是明文传输协议，HTTPS 协议是由 SSL+HTTP 协议构建的可进行加密传输、身份认证的网络协议，比 HTTP 协议安全。

- HTTPS比HTTP更加安全，对搜索引擎更友好，利于SEO,谷歌、百度优先索引HTTPS网页。

- HTTPS标准端口443，HTTP标准端口80。

- HTTPS需要用到SSL证书，而HTTP不用。


## HTTPS 加密过程

对称加密: 即通信的双方都使用同一个秘钥进行加解密，比如特务接头的暗号，就属于对称加密，但是首次发送秘钥容易被截胡

非对称加密: 

1. 私钥加公钥 = 密钥对
2. 私钥加密的数据只有对应的公钥才能解密，工要加密的数据只有私钥才能解密
3. 通信双方手里都有一套私钥对，**通信之前都会将公钥传给对方**
4. 对方拿到这个**公钥加密数据**响应给对方，然后接收方拿**私钥解密**拿到数据即可

**HTTPS加密过程**: HTTPS就是使用SSL/TLS协议进行加密传输，是结合两种加密方式，将对成加密的秘钥通过公钥加密，然后接收方使用私钥解密获取对称加密的秘钥，进而使用对称加密进行沟通数据。

**中间人和CA证书**: 但是这样就会有中间人产生，如果有人更换了公钥，这样数据就会很容易被解密，所以引入 CA证书 证明身份防止中间人攻击。

**数字签名**:  中间人篡改证书怎么办，这个时候数字签名就起了作用。数字签名是 CA 自带的哈希算法对证书内容进行哈希得到的摘要。

## 输入URL发生了什么

**加载过程**

- URL解析，如果有非法字符，就转义
- 浏览器查找当前URL是否存在缓存，并比较缓存是否过期
- DNS解析域名,域名->IP地址
- 浏览器与服务器建立tcp链接（三次握手）
- 发送请求，分析url，设置请求头
- 服务器返回请求的文件（html）

**渲染过程**

- 根据`HTML`、`Css`代码生成相应的`DOMTree`,`CSSOM`
- 结合`DOMTree`和`CSSOM`生成`RenderTree`，然后将`css`挂载在`DOM`上
- 根据`RenderTree`渲染页面
- 页面遇到`<script></script>`标签停止渲染,执行完`js`代码后再继续渲染
- layout布局渲染
- GPU像素绘制页面
- 直至渲染完成


