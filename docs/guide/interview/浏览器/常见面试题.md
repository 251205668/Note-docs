<!--
 * @Author: your name
 * @Date: 2020-11-13 16:38:09
 * @LastEditTime: 2020-11-13 16:38:30
 * @LastEditors: Please set LastEditors
 * @Description: In User Settings Edit
 * @FilePath: /Note-docs/docs/guide/interview/浏览器/常见面试题.md
-->

[https://juejin.im/post/6844904021308735502](https://juejin.im/post/6844904021308735502)


https://juejin.cn/post/6854573215830933512#heading-11


## 能不能说一说浏览器的本地存储？各自优劣如何？

- cookie: 为例弥补HTTP在状态管理上的不足。向同一个域名下发送请求，都会携带相同的 `Cookie`，服务器拿到 `Cookie` 进行解析，便能拿到客户端的状态。但是会有一系列的缺点
  - 容量缺陷：`Cookie` 的体积上限只有4KB

  - 性能缺陷：不管域名下面的某一个地址需不需要这个 Cookie ，请求都会携带上完整的 `Cookie`，请求携带了不必要的内容

  - 安全缺陷：`Cookie` 以纯文本的形式在浏览器和服务器中传递，很容易被非法用户截获，然后进行一系列的篡改

- localStorage：
  - 容量。`localStorage` 的容量上限为5M，相比于 `Cookie` 的 4K 大大增加。当然这个 5M 是针对一个域名的，因此对于一个域名是持久存储的。

  - 只存在客户端，默认不参与与服务端的通信。这样就很好地避免了 Cookie 带来的性能问题和安全问题。

  - 接口封装。通过 `localStorage` 暴露在全局，并通过它的 setItem 和 getItem等方法进行操作，非常方便。

- sessionStroage：`sessionStorage` 和 `localStorage` 有一个本质的区别，那就是前者只是会话级别的存储，并不是持久化存储。会话结束，也就是页面关闭，这部分 `sessionStorage` 就不复存在了。

- IndexedDB：`IndexedDB`是运行在浏览器中的非关系型数据库, 本质上是数据库，绝不是和刚才WebStorage的 5M 一个量级，理论上这个容量是没有上限的。
  - 键值对存储。内部采用对象仓库存放数据，在这个对象仓库中数据采用键值对的方式来存储。
  - 异步操作。数据库的读写属于 I/O 操作, 浏览器中对异步 I/O 提供了支持。
  - 受同源策略限制，即无法访问跨域的数据库。

## 重绘与回流

**重绘**:

当元素样式发生改变，但不影响布局时，浏览器将使用重绘进行元素更新，由于此时只需要UI层面的绘制，因此损耗较小

**回流**:

当**元素尺寸**、**结构**或者触发**某些属性**的时候，浏览器会重新渲染页面，这就叫回流。此时，浏览器需要重新计算，重新进行页面布局，所以损耗较大
一般有以下几种操作：

- 页面初次渲染
- 浏览器窗口大小改变
- 元素尺寸、位置、内容改变
- 元素字体大小改变
- 添加或删除可见的dom元素
- 触发CSS伪类，如:hover
- 查询某些属性或者调用某些方法
> clientWidth, clientHeight, clientTop, clientLeft
offsetWidth, offsetHeight, offsetTop, offsetLeft
scrollWidth, scrollHeight, scrollTop, scrollLeft
getComputedStyle()
getBoundingClientRect()
scrollTo()

**回流必定触发重绘，重绘不一定触发回流，重绘代价小，回流代价大**


## 如何避免重绘和回流

CSS:

- 避免使用table布局
- 尽可能再dom树的末端修改class
- 避免使用多层内联样式
- 将动画效果应用到position: absolute || fixed上
- 避免使用css表达式（例如calc）
- CSS3硬件加速（GPU加速）

JavaScript:

- 避免频繁操作样式，最好一次性修改style属性，或者将样式列表定义成class，并一次性更改class属性

- 避免频繁操作dom，创建一个documentFragment，在他上面应用所有的dom操作，最后再把他添加到文档中

- 也可以先为元素设置display: none，操作结束后再把它显示出来，因为再display为none的元素上进行dom操作不会引发重绘和回流

- 避免频繁读取会引发重绘回流的属性，如果需要多次使用，就用一个变量缓存起来

- 对具有复杂动画的元素使用绝对定位，使他脱离文档流，否则会引起父元素及后续元素频繁回流

- 使用cssText来更改样式


## websocket

http连接具有被动型，只能主动去向服务器请求看有没有新消息，一直轮询。

websocket是一个持久化的协议，连接了就不会自动断开。而且传递信息的时候只需要传递一点点头信息即可。一次握手，持久连接

- 先进行TCP三次握手
- TCP连接建立成功后，浏览器通过http协议发送websocket支持的版本号，地址等信息给服务端
- 服务端接受后，如果协议版本匹配，数据包格式正确，则接受连接
- 浏览器收到回复后，触发onopen事件，就可以通过send发送数据了

