# 常见面试题

[https://juejin.im/post/6844904021308735502](https://juejin.im/post/6844904021308735502)


https://juejin.cn/post/6854573215830933512#heading-11

## 常见的浏览器内核有哪些?

主要记住:

chrome：webkit ~ Blink
FileFox：Gecko(壁虎)
ie：Trident(三叉戟)

![](https://image.yangxiansheng.top/img/20201207132010.png?imglist)

## 浏览器的主要组成部分是什么？

1. 用户界面 ：除了浏览器主窗口显示的您请求的页面外
2. 浏览器引擎：用户界面和呈现引擎之间传送指令
3. 呈现引擎：负责显示请求的内容
4. 网络：用于网络调用，比如 HTTP 请求
5. 用户界面后端：用于绘制基本的窗口小部件
6. JavaScript解释器：用于解析和执行 JavaScript 代码
7. 数据存储：浏览器内数据库

## 浏览器是如何渲染UI的？

1. 浏览器获取HTML文件，然后对文件进行解析，形成DOM Tree
2. 与此同时，进行CSS解析，生成Style Rules
3. 接着将DOM Tree与Style Rules合成为 Render Tree
4. 接着进入布局（Layout）阶段，也就是为每个节点分配一个应出现在屏幕上的确切坐标
5. 随后调用GPU进行绘制（Paint），遍历Render Tree的节点，并将元素呈现出来

## DOM Tree是如何构建的？

1. 转码: 浏览器将接收到的二进制数据按照指定编码格式转化为HTML字符串
2. 生成Tokens: 之后开始parser，浏览器会将HTML字符串解析成Tokens
3. 构建Nodes: 对Node添加特定的属性，通过指针确定 Node 的父、子、兄弟关系和所属 treeScope
4. 生成DOM Tree: 通过node包含的指针确定的关系构建出DOM Tree

![](https://image.yangxiansheng.top/img/20201207133406.png?imglist)

## 能不能说一说浏览器的本地存储？各自优劣如何？

- cookie: 为例弥补HTTP在状态管理上的不足。向同一个域名下发送请求，都会携带相同的 `Cookie`，服务器拿到 `Cookie` 进行解析，便能拿到客户端的状态。但是会有一系列的缺点
  - 容量缺陷：`Cookie` 的体积上限只有4KB

  - 性能缺陷：不管域名下面的某一个地址需不需要这个 Cookie ，请求都会携带上完整的 `Cookie`，请求携带了不必要的内容

  - 安全缺陷：`Cookie` 以纯文本的形式在浏览器和服务器中传递，很容易被非法用户截获，然后进行一系列的篡改

- localStorage：
  - 容量。`localStorage` 的容量上限为5M，相比于 `Cookie` 的 4K 大大增加。当然这个 5M 是针对一个域名的，因此对于一个域名是持久存储的。

  - 只存在客户端，默认不参与与服务端的通信。这样就很好地避免了 Cookie 带来的性能问题和安全问题。

  - 接口封装。通过 `localStorage` 暴露在全局，并通过它的 setItem 和 getItem等方法进行操作，非常方便。

- sessionStroage：`sessionStorage` 和 `localStorage` 有一个本质的区别，那就是前者只是会话级别的存储，并不是持久化存储。会话结束，也就是页面关闭，这部分 `sessionStorage` 就不复存在了。

- IndexedDB：`IndexedDB`是运行在浏览器中的非关系型数据库, 本质上是数据库，绝不是和刚才WebStorage的 5M 一个量级，理论上这个容量是没有上限的。
  - 键值对存储。内部采用对象仓库存放数据，在这个对象仓库中数据采用键值对的方式来存储。
  - 异步操作。数据库的读写属于 I/O 操作, 浏览器中对异步 I/O 提供了支持。
  - 受同源策略限制，即无法访问跨域的数据库。

## 重绘与回流

**重绘**:

当元素样式发生改变，但不影响布局时，浏览器将使用重绘进行元素更新，由于此时只需要UI层面的绘制，因此损耗较小

**回流**:

当**元素尺寸**、**结构**或者触发**某些属性**的时候，浏览器会重新渲染页面，这就叫回流。此时，浏览器需要重新计算，重新进行页面布局，所以损耗较大
一般有以下几种操作：

- 页面初次渲染
- 浏览器窗口大小改变
- 元素尺寸、位置、内容改变
- 元素字体大小改变
- 添加或删除可见的dom元素
- 触发CSS伪类，如:hover
- 查询某些属性或者调用某些方法
> clientWidth, clientHeight, clientTop, clientLeft
offsetWidth, offsetHeight, offsetTop, offsetLeft
scrollWidth, scrollHeight, scrollTop, scrollLeft
getComputedStyle()
getBoundingClientRect()
scrollTo()

**回流必定触发重绘，重绘不一定触发回流，重绘代价小，回流代价大**


## 如何避免重绘和回流

CSS:

- 避免使用table布局
- 尽可能再dom树的末端修改class
- 避免使用多层内联样式
- 将动画效果应用到position: absolute || fixed上
- 避免使用css表达式（例如calc）
- CSS3硬件加速（GPU加速）

JavaScript:

- 避免频繁操作样式，最好一次性修改style属性，或者将样式列表定义成class，并一次性更改class属性

- 避免频繁操作dom，创建一个documentFragment，在他上面应用所有的dom操作，最后再把他添加到文档中

- 也可以先为元素设置display: none，操作结束后再把它显示出来，因为再display为none的元素上进行dom操作不会引发重绘和回流

- 避免频繁读取会引发重绘回流的属性，如果需要多次使用，就用一个变量缓存起来

- 对具有复杂动画的元素使用绝对定位，使他脱离文档流，否则会引起父元素及后续元素频繁回流

- 使用cssText来更改样式


## 前端如何实现即时通讯

**短轮询**

短轮询的原理很简单，每隔一段时间客户端就发出一个请求，去获取服务器最新的数据。

- 优点：兼容性强，实现非常简单
- 缺点：延迟性高，非常消耗请求资源，影响性能

**长轮询和长连接**

`comet` 有两种主要实现手段，一种是基于 `AJAX` 的长轮询方式，另一种是基于 `Iframe` 及 `htmlfile` 的流方式，通常被叫做长连接。

长轮询优缺点：

- 优点：兼容性好，资源浪费较小
- 缺点：服务器`hold`连接会消耗资源，返回数据顺序无保证，难于管理维护

长连接优缺点：

- 优点：兼容性好，消息即时到达，不发无用请求
- 缺点：服务器维护长连接消耗资源

**websocket**

`Websocket` 是一个全新的、独立的协议，基于 `TCP协议`，与 `http协议` 兼容、**却不会融入http协议**，仅仅作为html5的一部分，其作用就是在服务器和客户端之间建立实时的双向通信。

- 优点：真正意义上的实时双向通信，性能好，低延迟
- 缺点：独立与http的协议，因此需要额外的项目改造，使用复杂度高，必须引入成熟的库，无法兼容低版本浏览器

**SSE**

SSE（Server-Sent Event，服务端推送事件）是一种允许服务端向客户端推送新数据的HTML5技术

- 优点：基于HTTP而生，因此不需要太多改造就能使用，使用方便，而websocket非常复杂，必须借助成熟的库或框架
- 缺点：基于文本传输效率没有websocket高，不是严格的双向通信，客户端向服务端发送请求无法复用之前的连接，需要重新发出独立的请求


## 前端实现跨域

**浏览器同源策略**：

"协议+域名+端口"三者相同，不受同源限制的三个标签
- `<img src=XXX>`
- `<link href=XXX>`
- `<script src=XXX>`

**jsonp**

原理: 创建一个script标签, 再把需要请求的api地址放到src里. 这个请求只能用 `GET` 方法, 不可能是 `POST`，所以容易遭到XSS攻击

>**为什么只能实现 `get`** 
>
>如果看过 `JSONP` 库的源码就知道，常见的实现代码其实就是 `document.createElement(‘script’)` 生成一个 `script` 标签，然后插 `body` 里而已。在这里根本没有设置请求格式的余地

> **JSONP和AJAX对比**
JSONP 是非同源策略的AJAX

**手写 JSONP** 👍

JSONP函数一共需要三个参数: url,params,callback
1. 声明一个挂在全局的函数，函数名为 callback,获取服务器的返回的 `data`
2. 将 `callback` 和 `params`作为一个对象拼接参数
3. 新建 `script` 标签，将 `src` 设置为拼接好的参数，然后挂在到 `body` 上

```js
function JSONP({url,params,callback}){
  return new Promise((resolve,reject)=>{
    let script = document.createElement('script')
    // 声明回调
    window[callback] = function(data){
      resolve(data)
      document.body.removeChild(script)
    }
    // 拼接参数
    params = {...params,callback}
    let arr = []
    for(let key in params){
      arr.push(`${key}=${params[key]}`)
    }
    // 赋值src
    script.src = `${url}?${arr.join('&')}`
    document.body.append(script)
  })
}

// 使用实例

jsonp({
  url: 'http://localhost:3000/say',
  params: { wd: 'Iloveyou' },
  callback: 'show'
}).then(data => {
  console.log(data)
})


```


**cors**

服务端设置 `Access-Control-Allow-Origin` 就可以开启 `CORS`。 该属性表示哪些域名可以访问资源，如果设置通配符则表示所有网站都可以访问资源。

- Access-Control-Allow-Origin：设置哪个源可以访问我
- Access-Control-Allow-Methods：允许携带哪个方法访问我
- Access-Control-Allow-Headers：允许携带哪个头访问我
- Access-Control-Allow-Credentials：允许携带cookie
- Access-Control-Max-Age：预计的存活时间

```js
//CORS middleware
var allowCrossDomain = function(req, res, next) {
    res.header('Access-Control-Allow-Origin', 'http://example.com');
    res.header('Access-Control-Allow-Methods', 'GET,PUT,POST,DELETE');
    res.header('Access-Control-Allow-Headers', 'Content-Type');

    next();
}
```

**nginx**

反向代理的原理很简单，**即所有客户端的请求都必须先经过nginx的处理，nginx作为代理服务器再讲请求转发给node或者java服务，这样就规避了同源策略**。

![](https://image.yangxiansheng.top/img/20201207153722.png?imglist)

**WebSocket**

`WebSocket` 是一种双向通信协议，在建立连接之后，`WebSocket` 的 `server` 与 `client` 都能主动向对方发送或接收数据，连接建立好了之后 `client` 与 `server` 之间的双向通信就与 `HTTP` 无关了，因此可以跨域。

**postMessage()方法**

`HTML5 XMLHttpRequest` 有一个API，`postMessage()` 方法允许来自不同源的脚本采用异步方式进行有限的通信，可以实现跨文本档、多窗口、跨域消息传递。
